{% extends 'base.html' %}

{% block jumbotron %}
<div class="row row-header">
    <div class="col-5 col-sm-4 col-md-3 align-items-center align-self-center">
        <img src="{{ url_for('static', filename='img/ttv_plot.png') }}" class="img-fluid rounded">
    </div>
    <div class="col-7 col-sm-8 col-md-9 align-items-center align-self-center">
        <h1>Determining Planetary System Parameters With Transit Timing</h1>
    </div>
</div>
{% endblock %}

{% block body %}
<div class="modal" tabindex="-1" role="dialog" id="myPaper">
    <div class="modal-dialog modal-lg" role="document" style="min-width:70%; min-height:70%;">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    &times;
                </button>
            </div>
            <div class="modal-body">
                <div class="embed-responsive embed-responsive-4by3">
                    <embed class="embed-responsive-item" src="{{ url_for('static', filename='files/transittiming_paper.pdf') }}">
                </div>
            </div>
        </div>
    </div>
</div>

<body data-spy="scroll" data-target="#toc">
    <div class="container">
        <div class="row">
            <div class="col-12 col-md-3">
                <nav id="toc" data-toggle="toc" style="padding-top: 100px;" class="sticky-top d-none d-md-block">
                    <div class="btn-toolbar d-none d-md-block" role="toolbar" style="padding-left: 20px;">
                        <button type="button" class="btn btn-sm btn-warning mr-2 btn-outline-dark shadow-none sidebar-btn" data-toggle="tooltip" data-placement="top" title="Coming soon">Try It Out</button>
                        <a href="https://github.com/EthanHargrove/TTV-Inversion-Problem" target="_blank"><button type="button" class="btn btn-sm btn-warning btn-outline-dark sidebar-btn mt-1 mb-1"><i class="fa-brands fa-github fa-lg"></i> Code</button></a>
                    </div>
                </nav>
            </div>
            <div class="col-12 col-md-3 d-md-none">
                <nav id="toc" data-toggle="toc" class="sticky-top"></nav>
            </div>
            <div class="col-12 col-md-9">
                <hr class="border d-md-none">
                <div class="row">
                    <div class="col-12 col-md-9">
                        <p>
                            This is an expansion of my undergraduate research project, that was performed under the supervision of <a href="http://hanno-rein.de/" target="_blank">Professor Hanno Rein</a>.
                            <a href="{{ url_for('static', filename='files/transittiming_paper.pdf') }}" target="_blank"><button type="button" class="btn d-md-none btn-outline-light shadow-none">View paper</button></a>
                        </p>
                    </div>
                    <div class="col-3 d-none d-md-block">
                        <p>
                            <button type="button" class="btn d-none d-md-block btn-outline-light shadow-none" data-toggle="modal" data-target="#myPaper">
                                View paper
                            </button>
                        </p>
                    </div>
                </div>
                <hr class="border">
                <div class="row">
                    <div class="col-12">
                        <h2>Motivation</h2>
                        <p>
                            Exoplanets are planets that exist outside of our own solar system.<br>
                            A major motivation for studying exoplanets is to find planets that could potentially support life.
                            Since Earth is currently the only planet known to support life, this means we look for planets with features similar to Earth's.<br>
                            When determining the features of a planet, two of the main things we look at are its orbit and its composition.
                            The "habitable zone" is an area around a star where planets within could theoretically support surface liquid water. Planet's with orbits within their star's habitable zone are of particular interest.
                            By determing the mass and radius of a planet, we know its density and can predict its composition.
                        </p>
                        <div class="row">
                            <div class="col-6">
                                <img class="img-fluid rounded align-self-center" src="{{ url_for('static', filename='img/habitable.jpg') }}">
                                <figcaption style="font-size: 12px;">Image credit: NASA</figcaption>
                            </div>
                            <div class="col-6">
                                {% if dark_mode %}
                                <img class="img-fluid img-thumbnail rounded align-self-center" src="{{ url_for('static', filename='img/mass_radius.png') }}">
                                {% else %}
                                <img class="img-fluid rounded align-self-center" src="{{ url_for('static', filename='img/mass_radius.png') }}">
                                {% endif %}
                                <figcaption class="figure-caption" style="font-size: 12px; padding-left: 20px;">Created using Dr. Oscar Barrag&aacute;n's <a href="https://github.com/oscaribv/fancy-massradius-plot" target="_blank">fancy-massradius-plot</a></figcaption>
                            </div>
                        </div>
                        <p style="padding-top: 15px;">
                            The goal of this project is to create a tool for astronomers to use to determine the masses and orbital elements of the exoplanets they discover.
                        </p>
                    </div>
                </div>
                <hr class="border">
                <div class="row">
                    <div class="col-12">
                        <h2>Discovering Exoplanets</h2>
                        <p>
                            The most common method for exoplanet detection is the transit method.
                            A transit occurs when a planet crosses in front of star in the observer's line of sight.
                            This transit causes the star's light to dim slightly.
                            Observing periodic decreases in a star's light allows us to detect planets that we might not be able to directly see.
                            The period and magnitude of these decreases tell us the orbital period and radius of the planet.
                        </p>
                    </div>
                </div>
                <hr class="border">
                <div class="row">
                    <div class="col-12">
                        <h2>Transit Timing Variations</h2>
                        <p>
                            Recent increases in photometric precision allow us to observe changes in the periods of exoplanets over time.
                            These observed changes in orbital periods are known as transit timing variations (TTVs).
                            This phenomenon occurs due to gravitational interactions between the planets of the system.
                            This method enables us to calculate the masses and orbital elements of the planets and to detect non-transiting companion planets.<br><br>
                            To obtain the TTVs first measure the times of transits, then perform a linear least-squares fit transit times, and finally subtract the trendline from the measured transit times.<br><br>
                            Due to the conservation of energy, the TTVs of planetary companions are anti-correlated.
                        </p>
                        <div class="col-12 col-lg-10 offset-lg-1">
                            <figure>
                                {% if dark_mode %}
                                <img src="{{ url_for('static', filename='files/trappist1gif.gif') }}" class="img-fluid img-thumbnail">
                                {% else %}
                                <img src="{{ url_for('static', filename='files/trappist1gif.gif') }}" class="img-fluid">
                                {% endif %}
                                <figcaption class="figure-caption text-right text-lg-left"><a href="https://github.com/EthanHargrove/TTV-Inversion-Problem/blob/master/ttv_animation.py" class="btn btn-sm btn-outline-light shadow-none" target="_blank"><i class="fa-brands fa-github fa-lg"></i> Animation Code</a></figcaption>
                            </figure>
                        </div>
                    </div>
                </div>
                <hr class="border">
                <div class="row">
                    <div class="col-12">
                        <h2>Modelling Transits</h2>
                        <p>
                            Each body in a planetary system reacts gravitationally with all other bodies in the system.
                            In order to keep track of all these forces and predict the motion of the planets, we must use an N-body integrator.<br><br>
                            <a href="https://rebound.readthedocs.io/en/latest/?badge=latest" target="_blank"><i class="rebound-icon"></i>REBOUND</a> is an N-body integrator that evolves a system forward in time, one step at a time, by integrating over the equations of motion.
                            For REBOUND simulations the reference plane is the x-y plane and our reference direction is the positive axis.
                            When performing simulations using REBOUND, it is best to use the center-of-mass reference frame to decrease the numerical errors due to finite floating point precision as the center-of-mass and planets will slowly drift away from the origin.
                            In the center-of-mass frame a transit occurs when y<sub>planet</sub> - y<sub>star</sub> = 0 and x<sub>planet</sub> > 0.
                            These are the positively-sloped roots (x-intercepts) of their y-position relative to their star as a function of time.
                        </p>
                        {% if dark_mode %}
                        <img src="{{ url_for('static', filename='img/DeterminingTransits.png') }}" class="img-fluid img-thumbnail align-self-center">
                        {% else %}
                        <img src="{{ url_for('static', filename='img/DeterminingTransits.png') }}" class="img-fluid align-self-center">
                        {% endif %}
                        <figcaption class="fig-caption text-right" style="font-size: 11px;">Blue circles indicate a transit</figcaption>
                    </div>
                </div>
                <hr class="border">
                <div class="row">
                    <div class="col-12">
                        <h2>Finding the Roots</h2>
                        <p>
                            We have identified that the transit times of a planet are the positively positively-sloped roots of their relative y-position as a function of time.
                            Now we have to go about finding these roots; for this there are two major steps: bracketing the roots and converging upon them.
                        </p>
                        <h5>Bracketing the Roots</h5>
                        <p>
                            Due to the periodic nature of planetary motion, we must carefully determine an interval where exactly one root exists.
                            A simple and thorough way to go about this is to determine the position of each planet after every timestep, if a planet's previous y-position (relative to the star) was negative in the previous timestep and is positive in the current timestep, then we know that a transit has occured at some point during this interval.
                            This only works if the timestep used is less than half of the shortest orbital period in the system, else it is possible that a planet's previous and current y-position could have the same sign while a root exists between them.<br><br>
                            Checking the y-position of each planet every timestep can be slow and inefficient, especially when utilizing small timesteps.
                            We can estimate the transit times of each planet by analytically determing the transit times as if the planets were undergoing Keplerian (two-body) motion.
                            We can create a large bracket around these Keplerian transit times and use a root-finding algorithm to find the true, N-body transit time. This works for most systems, however it will have issues when perturbations to the Keplerian orbits are very large.
                        </p>
                        <h5>Derivation of the Keplerian Transit Times</h5>
                        <div class="row">
                            <div class="col-12 col-sm-4 align-self-sm-center">
                                <p>
                                    This derivation involves many of the orbital elements.
                                    A brief explanation of each element can be found at <a href="https://en.wikipedia.org/wiki/Orbital_elements" target="_blank">wikipedia.org</a>.
                                </p>
                            </div>
                            <div class="col-12 col-sm-8">
                                {% if dark_mode %}
                                <img class="img-fluid img-thumbnail align-self-center" src="{{ url_for('static', filename='img/orbital_elements.png') }}">
                                {% else %}
                                <img class="img-fluid align-self-center" src="{{ url_for('static', filename='img/orbital_elements.png') }}">
                                {% endif %}
                                <figcaption style="font-size: 10px;">By <a href="https://en.wikipedia.org/wiki/User:Lasunncty" target="_blank" class="extiw" title="en:User:Lasunncty">Lasunncty</a> at the <a href="https://en.wikipedia.org/wiki/" target="_blank" class="extiw" title="en:">English Wikipedia</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a target="_blank"  href="https://commons.wikimedia.org/w/index.php?curid=8971052">Link</a></figcaption>
                            </div>
                        </div>
                        <p>A planet's \(k^{\text{th}}\) transit can be determined using its orbital period \((P)\) and its first transit time \(t_{\text{transit}_0}\).
                            \[t_{\text{transit}_k} = (k \cdot P) + t_{\text{transit}_0}\]
                            Now we must find the first transit time for each planet. This can be done by dividing the difference between mean anomalies \((M)\) by the mean motion \((n)\) (Valladio & McClain 1997).
                        </p>
                        <p class="text-center" id="firstTrans">
                            \[t_{\text{transit}_0} =  \left\{
                                \begin{array}{ll}
                                    \frac{M_{\text{transit}} - M_{\text{initial}}}{n}+t_{\text{initial}} & \quad M_{\text{transit}} \geq M_{\text{initial}} \\\\
                                    \frac{M_{\text{transit}} - M_{\text{initial}} + 2\pi}{n}+t_{\text{initial}} & \quad M_{\text{transit}} \leq M_{\text{initial}}
                                \end{array}
                            \right.\]
                        </p>
                        <p>
                            We can find the initial mean anomaly and mean motion using <a href="https://rebound.readthedocs.io/en/latest/orbitalelements/" target="_blank">REBOUND</a>, but in order to use the above formula we must first calculate the mean anomaly at the time of transit.
                            This can be done using the eccentricity \((e)\), the true anomaly at the time of transit \((\nu_{\text{transit}})\), and Kepler's equation (Valladio & McClain 1997).
                            <figcaption><button class="btn btn-sm btn-outline-light shadow-none" type="button" data-toggle="collapse" data-target="#collapseMeanAnomaly" aria-expanded="false" aria-controls="collapseExample">View Steps</button></figcaption>
                        </p>
                        <div class="collapse" id="collapseMeanAnomaly">
                            <div class="card card-body">
                                <p>
                                    We want to find an expression for mean anomaly \((M)\) in terms of eccentricity \((e)\) and true anomaly \((\nu)\)
                                </p>
                                <p>
                                    Kepler's equation:
                                </p>
                                <p class="text-center text-eqn">
                                    \(M = E - e \cdot \sin{E}\)
                                </p>
                                <p>
                                    In <a href="https://www.amazon.ca/Fundamentals-Astrodynamics-Applications-Technology-Library/dp/1881883183" target="_blank">Fundamentals of Astrodynamics and Applications by Vallado</a>, the relationship between eccentric anomaly \((E)\) and true anomaly \((\nu)\) is given as:
                                </p>
                                <p class="text-center text-eqn">
                                    \(\sin{E} = \frac{\sqrt{1-e^2}\sin{\nu}}{1 + e \cdot \cos{\nu}} \; \; \; \) and \(\; \; \; \cos{E} = \frac{e + \cos{\nu}}{1 + e \cdot \cos{\nu}}\)
                                </p>
                                <p>
                                    Solving for \(E\) can be done in a number of ways. Given that we have expressions for \(\sin{E}\) and \(\cos{E}\), I opted to use arctan.
                                </p>
                                <p class="text-center text-eqn">
                                    \(\theta = \arctan(\tan(\theta)), \;\) if and only if \(\frac{-\pi}{2} < \theta < \frac{\pi}{2}\)
                                </p>
                                <p>
                                    However we want equality on the interval \([0, 2\pi)\).
                                    Using arctan2 instead of arctan gives us equality on the interval \((-\pi, \pi]\).
                                    Taking modulo \(2\pi\) of the result gives us equality on the interval \([0, 2\pi)\)
                                </p>
                                <p class="text-center text-eqn">
                                    \(M = (\text{arctan2}(\sin{E}, \cos{E}) \, \text{mod} \, (2\pi)) - e \cdot \sin{E} \)
                                </p>
                                <p>
                                    Substituting our expressions for \(\sin{E}\) and \(\cos{E}\).
                                </p>
                                <p class="text-center text-eqn">
                                    \(M = (\text{arctan2}(\frac{\sqrt{1-e^2}\sin{\nu}}{1 + e \cdot \cos{\nu}}, \frac{e + \cos{\nu}}{1 + e \cdot \cos{\nu}}) \, \text{mod} \, (2\pi)) - e \cdot \frac{\sqrt{1-e^2}\sin{\nu}}{1 + e \cdot \cos{\nu}} \)
                                </p>
                            </div>
                        </div>
                        <p class="text-center" id="meanAnomaly">
                            \[M_{\text{transit}} = (\text{arctan2}(\frac{\sqrt{1-e^2}\sin{\nu_{\text{transit}}}}{1 + e \cdot \cos{\nu_{\text{transit}}}}, \frac{e + \cos{\nu_{\text{transit}}}}{1 + e \cdot \cos{\nu_{\text{transit}}}}) \, \text{mod} \, (2\pi)) - e \cdot \frac{\sqrt{1-e^2}\sin{\nu_{\text{transit}}}}{1 + e \cdot \cos{\nu_{\text{transit}}}} \]
                        </p>
                        <p>
                            Note the use of the arctan2 function.
                            The arctan2 function is a two-argument arctangent function which uses the sign of the numerator and denominator to determine the quadrant of the result.
                            The range of the traditional arctan function is \((-\frac{\pi}{2}, \frac{\pi}{2})\).
                            Since mean anomaly is the angular distance from the pericenter we want the range of our results to be on the interval \([0, 2\pi)\).
                            By using the two-argument arctangent (Tsui 2005) we obtain results on the interval \((-\pi,\pi]\). Taking the result modulo \(2\pi\) gives us results on the desired \([0, 2\pi)\) interval.
                        </p>
                        <p class="text-center" id="arctan2">
                            \[\text{arctan2}(y,x) =  \left\{
                                \begin{array}{ll}
                                    \text{arctan}(\frac{y}{x}) & x > 0 \\\\
                                    \text{arctan}(\frac{y}{x})+\pi & x<0 \; \text{and} \; y \geq 0\\\\
                                    \text{arctan}(\frac{y}{x})-\pi & x<0 \; \text{and} \; y<0\\\\
                                    \frac{\pi}{2} & x=0 \; \text{and} \; y>0\\\\
                                    -\frac{\pi}{2} & x=0 \; \text{and} \; y<0\\\\
                                    0 & x=0 \; \text{and} \; y=0
                                \end{array}
                            \right.\]
                        </p>
                        <p>
                            For equation (3) we only need the eccentricity \((e)\), the true anomaly at the time of transit \((\nu_{\text{transit}})\).
                            We can find the eccentricity using <a href="https://rebound.readthedocs.io/en/latest/orbitalelements/" target="_blank">REBOUND</a>.
                            We can calculate \(\nu_{\text{transit}}\) by setting \(y=0\) in the conversion of orbital elements to heliocentric elliptic coordinates and solving for the true anomaly.
                            <figcaption><button class="btn btn-sm btn-outline-light shadow-none" type="button" data-toggle="collapse" data-target="#collapseTrueAnomaly" aria-expanded="false" aria-controls="collapseExample">View Steps</button></figcaption>
                        </p>
                        <div class="collapse" id="collapseTrueAnomaly">
                            <div class="card card-body">
                                <p>

                                </p>
                                <p class="text-center text-eqn">
                                    \(y = r(\sin(\Omega)\cos(\omega + \nu_{\text{transit}})+\cos(\Omega)\sin(\omega + \nu_{\text{transit}})\cos(i))=0\)
                                </p>
                                <p>
                                    r is the radial distance from the sun to the body. This value will not be equal to zero, so the only way the equation is zero is if the term it is multiplied by is equal to zero.
                                </p>
                                <p class="text-center text-eqn">
                                    \(\sin(\Omega)\cos(\omega + \nu_{\text{transit}})+\cos(\Omega)\sin(\omega + \nu_{\text{transit}})\cos(i)=0\)
                                </p>
                                <p class="text-center text-eqn">
                                    \(\sin(\Omega)\cos(\omega + \nu_{\text{transit}}) = - \cos(\Omega)\sin(\omega + \nu_{\text{transit}})\cos(i)\)
                                </p>
                                <p class="text-center">
                                    \(\frac{\sin(\Omega)}{\cos(\Omega)cos(i)} = - \frac{\sin(\omega + \nu_{\text{transit}})}{\cos(\omega + \nu_{\text{transit}})}\)
                                </p>
                                <p class="text-center">
                                    \(\frac{\sin(\Omega)}{\cos(\Omega)cos(i)} = - \tan(\omega + \nu_{\text{transit}})\)
                                </p>
                                <p>
                                    Use arctan2 instead of arctan to obtain results on the interval \((-\pi,\pi]\).
                                </p>
                                <p class="text-center text-eqn">
                                    \(\nu_{\text{transit}} = -\text{arctan2}(\sin(\Omega), \cos(i)\cos(\Omega)) - \omega\)
                                </p>
                            </div>
                        </div>
                        <p class="text-center" id="trueAnomaly">
                            \[\nu_{\text{transit}} = -\text{arctan2}(\sin(\Omega), \cos(i)\cos(\Omega)) - \omega\]
                        </p>
                        <p>
                            The longitude of ascending node \((\Omega)\), argument of pericenter \((\omega)\), and the inclination \((i)\) can all be calculated using <a href="https://rebound.readthedocs.io/en/latest/orbitalelements/" target="_blank">REBOUND</a>.<br><br>
                            To obtain a planet's \(k^{\text{th}}\) transit we need to use REBOUND to determine a planet's orbital elements, and use those elements to solve equation (5), then equation (3), then equation (2), and finally equation (1).
                        </p>
                        <h5>Converging Upon the Roots</h5>
                        <p>
                            After we bracket a root we can use a root-finding algorithm to converge towards it with a desired accuracy.
                            The Newton-Raphson method is a root-finding algorithm that uses the derivative of the function to generate guesses for the root.
                            The derivative is used to find the intercept of the tangent line, and setting that value as the new guess.
                            This method is very efficient when the initial guess is near the true value, and requires one posistion and one velocity calculation per iteration.<br>
                            In our center-of-mass frame we have:
                        </p>
                        <p class="text-center">
                            \(Y(t) = y_{\text{planet}} - y_{\text{star}}\) at time \(t\)<br>
                            \(Y'(t) = v_{y_{\text{planet}}} - v_{y_{\text{star}}}\) at time \(t\)
                        </p>
                        <p>
                            REBOUND keeps track of velocities at each time step, so the above calculations are painless.<br><br>
                            Newton's method utilizes these functions in the iterative process below.
                            Our initial guess \((t_0)\) will be the midpoint of the bracketed interval.
                        </p>
                        <p class="text-center">
                            \(t_{n+1} = t_n - \frac{Y(t_n)}{Y'(t_n)}\)
                        </p>
                        <p>
                            We repeat until \(|t_n - t_{n+1}| \leq \text{desired accuracy}\).
                        </p>
                        <div id="newtonCarousel" class="carousel slide carousel-fade" data-ride="carousel" data-interval="false">
                            <ol class="carousel-indicators">
                                <li data-target="#newtonCarousel" data-slide-to="0" class="active"></li>
                                <li data-target="#newtonCarousel" data-slide-to="1"></li>
                                <li data-target="#newtonCarousel" data-slide-to="2"></li>
                                <li data-target="#newtonCarousel" data-slide-to="3"></li>
                                <li data-target="#newtonCarousel" data-slide-to="4"></li>
                            </ol>
                            <div class="carousel-inner" role="listbox">
                                <div class="carousel-item active">
                                    <img src="{{ url_for('static', filename='img/bracket_root.png') }}" class="d-block w-100">
                                </div>
                                <div class="carousel-item">
                                    <img src="{{ url_for('static', filename='img/midpoint_root.png') }}" class="d-block w-100">
                                </div>
                                <div class="carousel-item">
                                    <img src="{{ url_for('static', filename='img/tangent_root.png') }}" class="d-block w-100">
                                </div>
                                <div class="carousel-item">
                                    <img src="{{ url_for('static', filename='img/tangent_zoom_root.png') }}" class="d-block w-100">
                                </div>
                                <div class="carousel-item">
                                    <img src="{{ url_for('static', filename='img/tangent_two_root.png') }}" class="d-block w-100">
                                </div>
                            </div>
                            <button class="carousel-control-prev" type="button" href="#newtonCarousel" data-slide="prev" id="newtonPrev">
                                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                                <span class="sr-only">Previous</span>
                            </button>
                            <button class="carousel-control-next" type="button" href="#newtonCarousel" data-slide="next" id="newtonNext">
                                <span class="carousel-control-next-icon" aria-hidden="true"></span>
                                <span class="sr-only">Next</span>
                            </button>
                        </div>
                        <p>
                            <br>
                            To ensure that we are finding the correct root, we will make sure that each Newton's guess lies within the bracketed interval.
                            If a guess is outside the interval we will do a bisection step, where we find the sign of the midpoint and set it as one of the brackets.
                        </p>
                        <div id="bisectionCarousel" class="carousel slide carousel-fade" data-ride="carousel" data-interval="false">
                            <ol class="carousel-indicators">
                                <li data-target="#bisectionCarousel" data-slide-to="0" class="active"></li>
                                <li data-target="#bisectionCarousel" data-slide-to="1"></li>
                                <li data-target="#bisectionCarousel" data-slide-to="2"></li>
                                <li data-target="#bisectionCarousel" data-slide-to="3"></li>
                            </ol>
                            <div class="carousel-inner" role="listbox">
                                <div class="carousel-item active">
                                    <img src="{{ url_for('static', filename='img/bracket_root2.png') }}" class="d-block w-100">
                                </div>
                                <div class="carousel-item">
                                    <img src="{{ url_for('static', filename='img/midpoint_root2.png') }}" class="d-block w-100">
                                </div>
                                <div class="carousel-item">
                                    <img src="{{ url_for('static', filename='img/update_bracket_root2.png') }}" class="d-block w-100">
                                </div>
                                <div class="carousel-item">
                                    <img src="{{ url_for('static', filename='img/start_over_root2.png') }}" class="d-block w-100">
                                </div>
                            </div>
                            <button class="carousel-control-prev" type="button" href="#bisectionCarousel" data-slide="prev" id="bisectionPrev">
                                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                                <span class="sr-only">Previous</span>
                            </button>
                            <button class="carousel-control-next" type="button" href="#bisectionCarousel" data-slide="next" id="bisectionNext">
                                <span class="carousel-control-next-icon" aria-hidden="true"></span>
                                <span class="sr-only">Next</span>
                            </button>
                        </div>
                    </div>
                </div>
                <hr class="border">
                <div class="row">
                    <div class="col-12">
                        <h2>TTV Inversion Problem</h2>
                        <p>
                            Now we are able to model a planetary system and determine its transit times.
                            However we want to determine the parameters of a planetary system given observed transit times.
                            This is the TTV inversion problem.<br><br>
                            We want to predict the input (planetary system parameters) from a given output (transit times) without knowledge of the relationship between inputs and outputs.
                            This can be solved as a minimization problem; where we minimize the mean absolute error between observed and modelled transit times as a function of system parameters.
                        </p>
                    </div>
                </div>
                <!-- <hr class="border">
                <div class="row">
                    <div class="col-12">
                        <h2>Procedural Generation of Planetary Systems</h2>
                        <p>
                            As of August 1st 2022, there are 5069 confirmed planets in the <a href="https://exoplanetarchive.ipac.caltech.edu/" target="_blank">NASA Exoplanet Archive</a>.
                            Some of these planets are orbiting the same star or were detected by methods other than the transit method.
                            This leaves us with not enough known planetary systems to train a machine learning model.
                            However, we are able to procedurally generate feasible planetary systems, model them using REBOUND, and determine their transit times.
                            The transit times will serve as inputs to the model and the planetary system parameters will be the output.
                        </p>
                        <h4>Stellar Mass</h4>
                        <p>
                            According to the NASA exoplanet archive the most massive known star with planets detected using the transit method is Kepler-1115 with a mass of approximately \(2.22 \, \text{M}_{\odot}\) and the least massive is Trappist-1 with an approximate mass of \(0.08 \, \text{M}_{\odot}\).
                            The mass of each star will be randomly selected according to a distribution derived from the <button class="btn btn-sm btn-outline-light shadow-none" type="button" data-toggle="collapse" data-target="#collapseKroupa" aria-expanded="false" aria-controls="collapseExample">Kroupa initial mass function</button> on the interval \([0.08, 2.22] \, \text{M}_{\odot}\).
                        </p>
                        <div class="collapse" id="collapseKroupa">
                            <div class="card card-body">
                                <p>
                                    The initial mass function (IMF), \(\xi(m)\), is the initial distribution of masses for stars, \(m =\) mass of star in \(\text{M}_{\odot}\), \(k =\) normalization constant. (Eq. 55 from <a href="https://arxiv.org/abs/1112.3340" target="_blank">Kroupa et al. 2013</a>).
                                </p>
                                <p id="kroupaIMF">
                                    \[\xi(m) = k \left\{
                                        \begin{array}{ll}
                                            (\frac{m}{0.07})^{-1.3} & 0.07 < m \leq 0.5\\\\
                                            \left[ (\frac{0.5}{0.07})^{-1.3} \right] (\frac{m}{0.5})^{-2.3} & 0.5 < m \leq 150
                                        \end{array}
                                    \right.\]
                                </p>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-12 col-lg-8 offset-lg-2">
                                <img src="{{ url_for('static', filename='img/stellar-mass.png') }}" class="d-block w-100">
                                <figcaption style="font-size: 12px;">50 000 stars were generated from the distribution, the figure above was obtained from a 100-bin histogram of the result.</figcaption>
                            </div>
                        </div>
                        <p><br></p>
                        <h4>Number of Planets</h4>
                        <p>
                            We will need a minimum of two bodies orbiting the star to observe TTVs.
                            Currently there are no known systems with more than eight planets.
                            The number of planets will be selected uniformly at random in \([2,8]\).
                        </p>
                        <h4>Planet Parameters</h4>
                        <p>
                            In order for our model to accuractely predict real-life systems we must train it using systems with realisitc parameters.
                            The planetary/orbital elements used in a REBOUND simulation are: mass, orbital period, eccentricity, inclination, longitude of ascending node, argument of pericenter, and true anomaly.
                            We can generate our planet parameters using known exoplanet distributions of these parameters.<br><br></p>
                        <h6>Mass and Orbital Period</h6>
                        <p>
                            Examining the relationship between planet mass and orbital period of known exoplanets we can see three distinct groups: small planets, hot Jupiters, and cold Jupiters.
                            When randomly generating planet masses and orbital periods we try to mimic this observed distribution.
                        </p>
                        <div class="row">
                            <div class="col-12 col-lg-6">
                                <figure>
                                    <img src="{{ url_for('static', filename='img/mass-period.jpg') }}" class="d-block w-100">
                                    <figcaption>Source: <a href="https://www.researchgate.net/publication/321901959_Stellar_Spin-Orbit_Alignment_for_Kepler-9_a_Multi-transiting_Planetary_System_with_Two_Outer_Planets_Near_21_Resonance" target="_blank">Wang et al. 2017</a></figcaption>
                                </figure>
                            </div>
                            <div class="col-12 col-lg-6">
                                <img src="{{ url_for('static', filename='img/random-mass-period.png') }}" class="d-block w-100">
                            </div>
                        </div>
                        <p>
                            There is also a general trend that more massive stars host larger planets <a href="https://arxiv.org/abs/2107.09534" target="_blank">(Lozovsky et al. 2021)</a>.
                            Gas giants are seldomly observed orbiting less massive stars such as red dwarfs.
                        </p>
                        <h6><br>Eccentricity</h6>
                        <p>
                            Known exoplanets with short orbital periods tend to have mostly circular orbits, whereas exoplanets with longer orbital periods tend to have slightly more eccentric orbits.
                            When randomly generating the eccentricity we try to mimic this observed distribution.
                        </p>
                        <div class="row">
                            <div class="col-12 col-lg-6">
                                <figure>
                                    <img src="{{ url_for('static', filename='img/eccentricity-period.png') }}" class="d-block w-100">
                                </figure>
                            </div>
                            <div class="col-12 col-lg-6">
                                <img src="{{ url_for('static', filename='img/random-eccentricity-period.png') }}" class="d-block w-100">
                            </div>
                        </div>
                        <h6><br>Inclination</h6>
                        <p>
                            Due to the nature of planet formation, all planets in the system will have roughly the same inclination.
                            Note there are rare counterexamples to this, such as Upsilon Andromedae c, which is inclined roughly \(30^{\circ}\) relative to the other planets (<a href="https://ui.adsabs.harvard.edu/abs/2010ApJ...715.1203M/abstract" target="_blank">McArthur et al. 2010</a>).
                            These planets will have inclinations of roughly zero relative to the observer, as they must pass in front of their star in order for a transit to be observed.
                            When randomly generating the eccentricity we try to mimic the distribution of known exoplanets.
                        </p>
                        <div class="row">
                            <div class="col-12 col-lg-10 offset-lg-1">
                                <img src="{{ url_for('static', filename='img/inclination-period-diagram.png') }}" class="d-block w-100">
                                <p><br></p>
                                <img src="{{ url_for('static', filename='img/random-inclination-period.png') }}" class="d-block w-100">
                                <p><br></p>
                            </div>
                        </div>
                        <h6>Longitude of Ascending Node and Argument of Pericenter</h6>
                        <p>
                            Among known planetary systems, the longitude of ascending node and argument of pericenter of each planet does not appear to be related to that of the other planets in the system.
                            So for each planet we will select the longitude of ascending node and argument of pericenter uniformly at random in \([0, 2\pi)\) radians.
                        </p>
                        <h6>True Anomaly</h6>
                        <p>
                            The true anomaly of a planet tells us its position in its orbit at a given time.
                            For the sake of our planet generation this is its initial position.
                            So we will select the true anomaly uniformly at random in \([0, 2\pi)\) radians.
                        </p>
                    </div>
                </div> -->
                <hr class="border">
                <div class="row">
                    <div class="col-12">
                        <h2>Minimization</h2>
                        <p>
                            Currently experimenting with different optimization algorithms and methods of determining initial guesses.
                        </p>
                    </div>
                </div>
                <hr class="border">
                <!-- <div class="row">
                    <div class="col-12">
                        <h2>Gradient Descent</h2>
                        <p>
                            Multivariate gradient descent starts with an initial guess and a cost function;
                            we then calculate the gradient of the cost function with respect to our predicted parameters and repeatedly adjust the parameters opposite to the gradient until we pass our desired cost function value.<br><br>
                            Our cost function will be the maximum absolute error and our target threshold will be the accuracy of our observed transit times.<br><br>
                            Our initial guesses for the orbital period will be the slope of the linear least squares fit for each planet's observed transit times.
                            We can then use our method of procedural planetary system generation to obtain our remaining initial guesses.<br><br>
                            At each step we can calculate the gradient by approximating the derivative of each parameter while keeping all other parameters constant at their previous guess.
                            This derivative approximation can be done using the central-difference approximation.
                            \[\frac{\partial f}{\partial x} \approx \frac{f(x + \frac{h}{2}, \, y, \, z, \ldots) - f(x - \frac{h}{2}, \, y, \, z, \ldots)}{h}\]
                            where \(h =\) step-size \(= x\sqrt[3]{\epsilon}\), and \(\epsilon = \) machine precision.<br>
                            Then we use these derivatives to simultaneously adjust each parameter.
                            \[\begin{matrix}
                            x_{n+1} = x_{n} - \alpha \frac{\partial f}{\partial x_{n}}\\
                            y_{n+1} = y_{n} - \alpha \frac{\partial f}{\partial y_{n}}\\
                            z_{n+1} = z_{n} - \alpha \frac{\partial f}{\partial z_{n}}\\
                            \vdots\\

                            \end{matrix}\]
                            where \(\alpha\) is the learning rate.<br>
                            We follow each set of updates with a cost function calculation and repeat until our threshold is met.
                        </p>
                    </div>
                </div>
                <hr class="border"> -->
            </div>
        </div>
    </div>
</body>
{% endblock %}

{% block script %}
<script>
    $(document).ready(function() {
        if(window.location.href.indexOf('#myPaper') != -1) {
            $('#myPaper').modal('show');
        }
    });
</script>
{% endblock %}